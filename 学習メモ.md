## kubernetes学習メモ


[仮想化環境](./out/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202023-02-04%2017.19.16.png)

1. minikubeのインストールを行う

## クラスタ実行/停止/状態確認

実行: minikube start --vm-driver=none
停止: minikube stop
状態確認: minikube status

## アドオンを操作するコマンド

追加: minikube addons enable ADDON_NAME
削除: minikube addons disable ADDON_NAME
一覧確認: minikube addons list

## Dockerコマンド復習
使われてないイメージを一括削除

`docker image prune`

## Kubernetes入門

### hello-worldをk8s上で実行する

- `kubectl run hello-world --
image hello-world --restart=Never`

- `kubectl get pod`で作られてか確認

- `kubectl logs pod/hello-world`でログを確認

### k8sとは？
コンテナオーケストレーション

システム運用で困っていたことが解決できる

- システムリソースの利用率に無駄がある → 複数コンテナの共存
- 突発的な大量アクセスでシステムが応答しなくなった → 水平スケール
- 突然、一部システムがダウンした → 監視 & 自動デプロイ
- リリースのたびにサービス停止が発生する → ローリングデプロイ

使えるリソースを一元管理

マスターノードとワーカーノードが存在する

マスターノードを経由して各ワーカーノードを操作する

4分類10種類のリソース

ワークロード
 - Pod
 - ReplicaSet
 - Deployment
 - StatefulSet

サービス
 - Service
 - Ingress

設定
 - ConfigMap
 - Secret

ストレージ
 - PersistentVolume
 - PersistentVolumeClaim

リソース作成コマンド

`kubectl apply -f pod.yml`

pod.ymlはマニフェストファイル

種別: kindはリソース種別。kindによってapiVersionは決まっている

メタデータ: Pod名は名前空間と合わせて一意にする。

コンテナ定義: spec内にコンテナ名を指定、どのイメージを指定するかもできる。

Secretリソースのコマンド作成

`kubectl create secret generic NAME OPTIONS`

k8sとDockerのコマンド操作の違い
Docker: ENTRYPOINT
k8s: command

Docker: CMD
k8s: args

apiVersionはk8sのreferenceから確認

コンテナへ入る
kubectl exec -it POD sh

exitでコンテナから出る

### ファイル転送

`kubectl cp SRC DEST`
SRC: 転送元ファイル
DEST: 転送先ファイル

例

`kubectl cp ./sample.txt debug:/var/tmp/sample.txt`

### ログの確認

状態の確認

kubectl describe [TYPE/NAME]

例
kubectl describe pod/debug

ログの確認(アクセスログなど)

kubectl logs [TYPE/NAME]

`kubectl get pod -o wide`でipアドレスも確認可能

## Pod
最小単位、同一環境で動作するDockerコンテナの集合

複数のコンテナを所有することが可能


## ConfigMapについて学ぶ

k8sで使用する設定情報を集約するファイル


